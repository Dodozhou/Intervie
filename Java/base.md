### 基础
1. Java表达式转型规则由低到高转换
    * 所有的byte,short,char型的值将被提升为int型；
    * 如果有一个操作数是long型，计算结果是long型；
    * 如果有一个操作数是float型，计算结果是float型；
    * 如果有一个操作数是double型，计算结果是double型；
    * 被final修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。
### JVM

1. Java GC如何判断对象是否为垃圾  
根搜索算法，根：
    * 虚拟机栈中引用的对象（本地变量表）
    * 方法区中静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中引用的对象（Native对象）
1. JVM的垃圾收集器主要有哪些，各自的特点是什么？

16. 为什么要设置工作内存和主内存  
    缓存加速，相当于是内存和硬盘的关系。
17. 当发现虚拟机频繁GC时应该怎么办？  
    【待补充】  
2. 请描述java的内存分区  
    【待补充】  
3. 请描述java的对象生命周期，以及对象的访问？   
    【待补充】  
1. JVM调优  
    【待补充】  

### 接口
1. 抽象类和接口的区别
    * 接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。
    * abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。
    * 在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。
    * abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"has-a"关系。
    * 实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。
    * 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。
### IO
1. java中有几种类型的流？jdk为每种类型的流提供了一些抽象类以供继承，请说出它们分别是什么？
    * 字符流和字节流。字节流继承inputStream和OutputStream,字符流继承自InputSteamReader和OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。
2. 简述一下将文件中的数据输入到另一个文件中的步骤
    1. 首先创建File对象，并且和需要操作的文件相关联，这时候需要对文件进行判断是否存在，不存在则会报错
    2. 既然是读取文件并且写到文件，属于纯文本，可以选择FileReader和FileWriter进行读写操作,如果出现乱码可以使用其父类指定编码方式
    3. 创建FileReader对象用于读取文件中的数据，这里可以使用缓冲流进行处理，提高效率，创建一个BufferedReader对象
### 多线程
1. start()方法和run()方法的区别
   * 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。
2. sleep方法和wait方法有什么区别
    * 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器
3. 怎么唤醒一个阻塞的线程
    * 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
4. 什么是乐观锁和悲观锁
    * （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
      （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
5. 什么是AQS
    * 简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。
如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。
AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。
999. 什么是线程安全？
* 答案很多，但是我的理解是如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的

这个问题有值得一提的地方，就是线程安全也是有一个级别的
i. 不可变
* 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用

ii. 绝对线程安全
* 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet

iii. 相对线程安全
* 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

iv. 线程非安全
* ArrayList、LinkedList、HashMap等都是线程非安全的类


   3. 一个线程如果出现了运行时异常会怎么样

* 如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放

4. 如何在两个线程之间共享数据
* 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的


### hash
1. 我们能否使用任何类作为Map的key？
我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：
    * 如果类重写了equals()方法，它也应该重写hashCode()方法。
    * 类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。
    * 如果一个类没有使用equals()，你不应该在hashCode()中使用它。
    * 用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。
### Linux 命令
1. 常用命令  
    * https://www.zhihu.com/question/64063454
    1. cd 切换路径
    2. ls 列出文件
        * -l ：列出长数据串，包含文件的属性与权限数据等  
        * -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）  
        * -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来  
    3. cp 复制
        * -a ：将文件的特性一起复制  
        * -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份  
        * -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行  
        * -r ：递归持续复制，用于目录的复制行为  
        * -u ：目标文件与源文件有差异时才会复制  
    4. mv 移动
        * -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖  
        * -i ：若目标文件已经存在，就会询问是否覆盖  
        * -u ：若目标文件已经存在，且比目标文件新，才会更新  
    5. rm 删除
        * -f ：就是force的意思，忽略不存在的文件，不会出现警告消息  
        * -i ：互动模式，在删除前会询问用户是否操作  
        * -r ：递归删除，最常用于目录删除，它是一个非常危险的参数  
    6. ps 查看进程
        * ps aux # 查看系统所有的进程数据  
        * ps ax # 查看不与terminal有关的所有进程  
        * ps -lA # 查看系统所有的进程数据  
        * ps axjf # 查看连同一部分进程树状态  
    7. kill 关闭
        * kill pid
    8. file 判断接在file命令后的文件的基本数据
    9. tar 打包
        * 压缩：tar -zcv -f filename.tar.gz 要被处理的文件或目录名称  
        * 查询：tar -ztv -f filename.tar.gz 
        * 解压：tar -zxv -f filename.tar.gz -C 欲解压缩的目录  
    10. cat 查看文本文件的内容
    11. time 用于测算一个命令（即程序）的执行时间
        * 在命令的前面加入一个time即可
    12. pwd 显示当前目录