### 基础
1. Java表达式转型规则由低到高转换
    * 所有的byte,short,char型的值将被提升为int型；
    * 如果有一个操作数是long型，计算结果是long型；
    * 如果有一个操作数是float型，计算结果是float型；
    * 如果有一个操作数是double型，计算结果是double型；
    * 被final修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。
2. Java和c#中statis关键字的作用
    1. java中
        * static可以用来定义静态成员变量、静态函数、静态代码块
        ```
        class Person{
            static int i; //静态成员变量
        }
        
        ```
        普通成员变量![osi](https://raw.githubusercontent.com/yzrds/Interview/master/img/普通成员变量.png)
        静态成员变量:在静态的成员变量中，所有的对象使用的成员变量是同一个，值也一样。当静态成员变量的值被修改了，对象的成员变量值也跟着变化。静态成员变量可以直接用类名来调用，也可以用对象来调用静态成员变量。
        静态成员变量[](https://raw.githubusercontent.com/yzrds/Interview/master/img/静态成员变量.png)
        * 在静态函数中不能使用非静态的成员变量
     2. c#中
     * 用在类里的属性、方法前面，这样的静态属性与方法不需要创建实例就能访问，
     通过类名或对象名都能访问它，静态属性、方法只有“一份”：即如果一个类新建有N个
     对象，这N 个对象只有同一个静态属性与方法；
     * 方法内部的静态变量：
     方法内部的静态变量，执行完静态变量值不消失，再次执行此对象的方法时，值仍存在，
     它不是在栈中分配的，是在静态区分析的， 这是与局部变量最大的区别；   
### JVM

1. Java GC如何判断对象是否为垃圾  
根搜索算法，根：
    * 虚拟机栈中引用的对象（本地变量表）
    * 方法区中静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中引用的对象（Native对象）
2. Java的GC机制
    * Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了.
1. JVM的垃圾收集器主要有哪些，各自的特点是什么？

16. 为什么要设置工作内存和主内存  
    缓存加速，相当于是内存和硬盘的关系。
17. 当发现虚拟机频繁GC时应该怎么办？  
    【待补充】  
2. 请描述java的内存分区  
    【待补充】  
3. 请描述java的对象生命周期，以及对象的访问？   
    【待补充】  
1. JVM调优  
    【待补充】  

### 接口
1. 抽象类和接口的区别
    * 接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。
    * abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。
    * 在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。
    * abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"has-a"关系。
    * 实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。
    * 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。
### IO
1. java中有几种类型的流？jdk为每种类型的流提供了一些抽象类以供继承，请说出它们分别是什么？
    * 字符流和字节流。字节流继承inputStream和OutputStream,字符流继承自InputSteamReader和OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。
2. 简述一下将文件中的数据输入到另一个文件中的步骤
    1. 首先创建File对象，并且和需要操作的文件相关联，这时候需要对文件进行判断是否存在，不存在则会报错
    2. 既然是读取文件并且写到文件，属于纯文本，可以选择FileReader和FileWriter进行读写操作,如果出现乱码可以使用其父类指定编码方式
    3. 创建FileReader对象用于读取文件中的数据，这里可以使用缓冲流进行处理，提高效率，创建一个BufferedReader对象
### 多线程
1. start()方法和run()方法的区别
   * 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。
2. sleep方法和wait方法有什么区别
    * 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器
3. 怎么唤醒一个阻塞的线程
    * 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
4. 什么是乐观锁和悲观锁
    * （1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
      （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
5. 什么是AQS
    * 简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。
如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。
AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。
6. 什么是线程安全？
* 答案很多，但是我的理解是如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的

这个问题有值得一提的地方，就是线程安全也是有一个级别的
i. 不可变
* 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用

ii. 绝对线程安全
* 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet

iii. 相对线程安全
* 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。

iv. 线程非安全
* ArrayList、LinkedList、HashMap等都是线程非安全的类


   3. 一个线程如果出现了运行时异常会怎么样

* 如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放

4. 如何在两个线程之间共享数据
* 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的
3. IO模型有哪些？【待理解】

### 并发
1. 锁（lock）和监视器（monitor）有什么区别？
    * 锁是为了实现监视器排他性的一种手段
2. 怎么唤醒一个阻塞的线程
    * 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；
    * 如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
3. Java中如何停止一个线程？
       * 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
       * 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。
       * 使用interrupt方法中断线程。
4. 如何避免死锁？
    * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：
        * 互斥条件：一个资源每次只能被一个进程使用。
        * 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
        * 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
        * 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
    * 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。
5. 线程池的使用场景
    1. 高并发、任务执行时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下文的切换
    2. 并发不高、任务执行时间长的业务要区分开看：
        * 假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务
        * 假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换
    3. 并发高、业务执行时间长：解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。
### 计算机网络

1. http和https区别  
    HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。  
    HTTPS和HTTP的区别主要如下：
        * https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
        * http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
        * http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
        * http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
2. 说一下什么是Http协议？  
    对器客户端和服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”。
3. 什么是Http协议无状态协议？怎么解决Http协议无状态协议？（曾经去某创业公司问到）
        * 无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息
        * 无状态协议解决办法： 通过1、Cookie 2、通过Session会话保存。
4. 说一下Http协议中302状态  
    http协议中，返回状态码302表示重定向。这种情况下，服务器返回的头部信息中会包含一个 Location 字段，内容是重定向到的url
5. Http协议有什么组成？
        1. 请求报文 包含三部分：
            * 请求行：包含请求方法、URI、HTTP版本信息
            * 请求首部字段
            * 请求内容实体
        2. 响应报文 包含三部分：
            * 状态行：包含HTTP版本、状态码、状态码的原因短语
            * 响应首部字段
            * 响应内容实体
6. Http协议中有那些请求方式？
        * GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
        * POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
        * PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
        * HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
        * DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
        * OPTIONS：查询相应URI支持的HTTP方法。
7. Http协议中Http1.0与1.1区别？
        * 在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。
        * 在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。
8. get与post请求区别？
        * get重点在从服务器上获取资源，post重点在向服务器发送数据；
        * get传输数据是通过URL请求，post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
        * Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；
        * get是不安全的，因为URL是可见的，可能会泄露信息；post较get安全性较高；
9. 常见Http协议状态？
        * 1**	信息，服务器收到请求，需要请求者继续执行操作
        * 200 - 请求成功
        * 301 - 资源（网页等）被永久转移到其它URL
        * 404 - 请求的资源（网页等）不存在
        * 500 - 内部服务器错误
10. Http优化
        * 利用负载均衡优化和加速HTTP应用
        * 利用HTTP Cache来优化网站

### 操作系统
1. 进程有哪几种状态？
    * 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
    * 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
    * 阻塞状态： 进程等待某种条件，在条件满足之前无法执行 
2. 不同操作系统实现进程有什么区别
    * [点击这里](http://blog.csdn.net/zyq522376829/article/details/47903101)

### hash
1. 我们能否使用任何类作为Map的key？
我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：
    * 如果类重写了equals()方法，它也应该重写hashCode()方法。
    * 类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。
    * 如果一个类没有使用equals()，你不应该在hashCode()中使用它。
    * 用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。
### Linux 命令
1. 常用命令  
    * https://www.zhihu.com/question/64063454
    1. cd 切换路径
    2. ls 列出文件
        * -l ：列出长数据串，包含文件的属性与权限数据等  
        * -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）  
        * -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来  
    3. cp 复制
        * -a ：将文件的特性一起复制  
        * -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份  
        * -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行  
        * -r ：递归持续复制，用于目录的复制行为  
        * -u ：目标文件与源文件有差异时才会复制  
    4. mv 移动
        * -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖  
        * -i ：若目标文件已经存在，就会询问是否覆盖  
        * -u ：若目标文件已经存在，且比目标文件新，才会更新  
    5. rm 删除
        * -f ：就是force的意思，忽略不存在的文件，不会出现警告消息  
        * -i ：互动模式，在删除前会询问用户是否操作  
        * -r ：递归删除，最常用于目录删除，它是一个非常危险的参数  
    6. ps 查看进程
        * ps aux # 查看系统所有的进程数据  
        * ps ax # 查看不与terminal有关的所有进程  
        * ps -lA # 查看系统所有的进程数据  
        * ps axjf # 查看连同一部分进程树状态  
    7. kill 关闭
        * kill pid
    8. file 判断接在file命令后的文件的基本数据
    9. tar 打包
        * 压缩：tar -zcv -f filename.tar.gz 要被处理的文件或目录名称  
        * 查询：tar -ztv -f filename.tar.gz 
        * 解压：tar -zxv -f filename.tar.gz -C 欲解压缩的目录  
    10. cat 查看文本文件的内容
    11. time 用于测算一个命令（即程序）的执行时间
        * 在命令的前面加入一个time即可
    12. pwd 显示当前目录