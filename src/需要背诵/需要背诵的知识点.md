# 面试知识点总结
* 以下内容为重点背诵的内容
* 笔记向，不定期更新。
* 自己总结，如果有错的地方欢迎指正。
* 以下所有内容均来自于互联网
* 部分内容为个人整理和提炼，侵删。
* 找到工作了。。。可能维护缓慢了，有兴趣一起维护的可以私聊我

# 数据库
1. 什么是索引  
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。
1. 什么时候使用索引  
    * 能够提升效率的时候使用索引。  
        * 在作为主键的列上，唯一性约束的列（不过大部分数据库会自动加索引）；
        * 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
        * 在经常需要排序的列上创建索引，这样查询可以利用索引的排序，加快排序查询时间；
        * 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
    * 不能够提升效率的时候不使用索引，例如：该列很少进行查找或排序操作

1. 事务（Transaction）
    * 事务是是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
    * 事务的四个属性 
        * 原子性 Atomic  
        就是事务应作为一个工作单元,事务处理完成，所有的工作要么都在数据库中保存下来，要么完全回滚，全部不保留 
        * 一致性 Consistent  
        事务完成或者撤销后，都应该处于一致的状态
        * 隔离性 Isolated  
        多个事务同时进行，它们之间应该互不干扰.应该防止一个事务处理其他事务也要修改的数据时，不合理的存取和不完整的读取数据 
        * 永久性 Durable  
        事务提交以后，所做的工作就被永久的保存下来 

# 计算机网络
1. http
    1. http和https区别  
    HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。  
    1. 说一下什么是Http协议？  
    对器客户端和服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”。
    4. Http协议有什么组成？
        1. 请求报文 包含三部分：
            * 请求行：包含请求方法、URI、HTTP版本信息
            * 请求首部字段
            * 请求内容实体
        2. 响应报文 包含三部分：
            * 状态行：包含HTTP版本、状态码、状态码解释
            * 响应首部字段
            * 响应内容实体
    6. Http协议中Http1.0与1.1区别？
        * 在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。
        * 在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。
1. DNS解析的方法  
当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并称为DNS的一个客户，
把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。
本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。
应用程序获得目的主机的IP地址后即可进行通信。
若本地域名服务器不能回答该请求，则此域名服务器就暂时称为DNS的另一个客户，
并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止。

1. TCP 和 UDP


# Java
1. JVM的垃圾收集器主要有哪些，各自的特点是什么？
    * Serial\[ˈsɪriəl\]
        * 新生代的算法
        * 单线程复制算法
    * Serial\[ˈsɪriəl\] Old 
        * 老年代的算法
        * 单线程标记-整理算法
    * Parallel\[ˈpærəˌlɛl\](ParNew)
        * 新生代的算法
        * serial的多线程版本
    * Parallel Scavenge\[ˈskævəndʒ\]
        * 新生代的算法
        * 目标则是达到一个可控制的吞吐量（Throughput）。
        * 其他和ParNew类似
    * Parallel Old
        * 老年代的算法
        * Serial Old 的多线程版本
    * CMS
        * 老年代的算法
        * 初始标记（CMS initial mark）
        * 并发标记（CMS concurrent mark）
        * 重新标记（CMS remark）
        * 并发清除（CMS concurrent sweep）
        * 因为是基于标记-清除的，所以会有内存碎屏，顶不住的时候会提前触发full gc。
        * 但是默认full gc会进行内存合并
        * 可以设置参数控制多少次full gc整理一次内存
    * G1
        * 分块处理
        * 并行与并发
        * 分代收集
        * 空间整合
        * 可预测的停顿

1. 线程池
    * 用Executors可以创建
        * ExecutorService newCachedThreadPool() 
          创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。
        * ExecutorService newFixedThreadPool(int nThreads) 
          创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。
        * ScheduledExecutorService	newScheduledThreadPool(int corePoolSize) 
          创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
        * ExecutorService newSingleThreadExecutor() 
          创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。
        * ScheduledExecutorService newSingleThreadScheduledExecutor() 
          创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。
1. CountDownLatch
    * CountDownLatch latch = new CountDownLatch(2);
    * 在await()之前必须执行两次latch.countDown()否则将阻塞
    * latch.await();
1. CyclicBarrier  
    * CyclicBarrier简单的理解就是内存屏障
    * CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。 
    * CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。
    * 具体见代码
    ```java
    //当所有线程到达barrier时执行，这里的lambda是Runnable(可选参数)
    CyclicBarrier cb = new CyclicBarrier(THREAD_NUM, () -> System.out.println("Inside Barrier"));
    for (int i = 0; i < THREAD_NUM; i++) {
        new Thread(() -> {
            //线程在这里等待，直到所有线程都到达barrier。
            cb.await();
        }).start();
    }
    ```

# 操作系统和Linux
1. 进程的通信方式  
    * 管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
    * 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
    * 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
    * 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
    * 套接字：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

1. 操作系统中进程调度策略
    * 先来先服务
    * 优先级
    * 短作业优先
    * 时间片轮转
    * 最高响应比优先算法(HRN)：响应比=1+作业等待时间/作业处理时间。

1. 文件权限
    * 每个Linux文件具有四种访问权限：可读(r)、可写(w)、可执行(x)和无权限(-)。
    * 利用ls -l命令可以看到某个文件或目录的权限，它以显示数据的第一个字段为准。第一个字段由10个字符组成，如下：
    * 1234567890
    * -rwxr-xr-x
    * 第一位表示文件类型，-表示文件，d表示目录
    * 2-4位：　　表示文件所有者的权限，u权限
    * 5-7位：　　表示文件所有者所属组成员的权限，g权限
    * 8-10位：　　表示所有者所属组之外的用户的权限，o权限   
    * 2-10位：　　的权限总和有时称为a权限

# 设计模式
* 全部 要求看到名字想到例子

# 算法和思维
1. 排序
    * 非稳定排序：选择排序、快速排序、希尔排序、堆排序
    * 稳定排序：冒泡排序、插入排序、归并排序和基数排序

1. 手推红黑树查找，删除
8. 数据库索引的分类，优化方式(聚簇索引，非聚簇索引，覆盖，复合索引等等的概念)
9. MyISAM 和InnoDB 的区别，实现方式。
    区别：
    1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  
    2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  
    3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
    4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  
    5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；   
    如何选择：
    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；
    2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。
    3. 系统奔溃后，MyISAM恢复起来更困难，能否接受； 
    4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

10. 设计模式，解释了几个常用的
13. 一个网站请求从客户端到服务器端的过程
14. JVM，内存模型，GC，类加载器，反射等等的知识。
15. Spring框架的启动流程
16. Sring框架IOC和AOP的实现原理，写了一个简易的IOC和一个AOP
1. hashmap 与hastable，concurrenthashmap相互的关联和区别
19.synchronized与lock的区别
20.java中的锁，偏向，轻，重，的转换
常用Linux命令，
手写多线程计数，
synchronized，同步对象是谁？
进程间通信，线程间通信，线程池。
有1000盏灯，最开始关灯，然后全部打开，然后把2的倍数的灯熄灭，然后把3的倍数的灯打开，以此类推。
最后有多少盏灯是熄灭的，或者有多少盏灯是开着的，说出编号。按照编号数少方式的说


1. 给一个文件，文件的第三列是ip使用率，用linux命令查出ip使用率最高的那个ip地址
sort -n -k 3 data2 | tail -n 1 | awk '{print $1}'
2. 找出第三列重复最多的字符串
cat data | awk '{print $3}' | sort | uniq -c | sort | tail -n 1
3. 给三个文件，把三个文件合并为一个文件
